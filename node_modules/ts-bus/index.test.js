"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var index_1 = require("./index");
var mockWarn = jest.fn();
console.warn = mockWarn;
describe("Basic usage", function () {
    describe("createEventDefinition", function () {
        it("should work with createEventDefinition", function () {
            // mock subscription
            var handleSubscription = jest.fn();
            var myEventCreator = index_1.createEventDefinition()("myevent");
            // create a bus
            var bus = new index_1.EventBus();
            bus.subscribe(myEventCreator, handleSubscription);
            // create n event
            var event = myEventCreator({ foo: "Hello" });
            // Call it once
            bus.publish(event);
            expect(handleSubscription.mock.calls).toEqual([
                [
                    {
                        type: "myevent",
                        payload: { foo: "Hello" }
                    }
                ]
            ]);
            // call a few times
            bus.publish(event);
            bus.publish(event);
            bus.publish(event);
            expect(handleSubscription.mock.calls.length).toBe(4);
        });
        describe("createEmptyEventDefinition", function () {
            it("should work with createEmptyEventDefinition and an empty payload", function () {
                // mock subscription
                var handleSubscription = jest.fn();
                var myEventCreator = index_1.createEventDefinition()("myevent");
                // create a bus
                var bus = new index_1.EventBus();
                bus.subscribe(myEventCreator, handleSubscription);
                // create n event
                var event = myEventCreator();
                // Call it once
                bus.publish(event);
                expect(handleSubscription.mock.calls).toEqual([
                    [
                        {
                            type: "myevent",
                            payload: undefined
                        }
                    ]
                ]);
            });
        });
        it("should show deprecation warning when using defineEvent", function () {
            mockWarn.mockReset();
            index_1.defineEvent("myevent");
            expect(mockWarn.mock.calls[0][0]).toEqual("defineEvent is deprecated and will be removed in the future. Please use createEventDefinition instead.");
        });
        it("should allow runtime type warnings", function () {
            mockWarn.mockReset();
            var testFn = function (o) { return o.foo && typeof o.foo === "string"; };
            var myEventCreator = index_1.createEventDefinition(testFn)("myevent");
            // @ts-ignore
            myEventCreator({ ding: "baz" });
            expect(mockWarn.mock.calls[0][0]).toEqual("{\"ding\":\"baz\"} does not match expected payload.");
        });
        it("should allow runtime type warnings with the options object", function () {
            mockWarn.mockReset();
            var testFn = function (o) { return o.foo && typeof o.foo === "string"; };
            var myEventCreator = index_1.createEventDefinition({ test: testFn })("myevent");
            // @ts-ignore
            myEventCreator({ ding: "baz" });
            expect(mockWarn.mock.calls[0][0]).toEqual("{\"ding\":\"baz\"} does not match expected payload.");
        });
        it("should allow string coercion to return the eventType", function () {
            var myEventCreator = index_1.createEventDefinition()("myevent");
            expect(String(myEventCreator)).toEqual("myevent");
        });
    });
    it("should respond to events being dispatched", function () {
        // mock subscription
        var handleSubscription = jest.fn();
        var myEventCreator = index_1.defineEvent("myevent");
        // create a bus
        var bus = new index_1.EventBus();
        bus.subscribe(myEventCreator, handleSubscription);
        // create n event
        var event = myEventCreator({ foo: "Hello" });
        // Call it once
        bus.publish(event);
        expect(handleSubscription.mock.calls).toEqual([
            [
                {
                    type: "myevent",
                    payload: { foo: "Hello" }
                }
            ]
        ]);
        // call a few times
        bus.publish(event);
        bus.publish(event);
        bus.publish(event);
        expect(handleSubscription.mock.calls.length).toBe(4);
    });
    describe("multi subscription", function () {
        it("should subscribe to multiple events at once", function () {
            var handleSubscription = jest.fn();
            var greetEvent = index_1.defineEvent("greet");
            var testFooEvent = index_1.defineEvent("test.foo");
            var otherEvent = index_1.defineEvent("notsubscribed");
            var myTargetedEventType = "test.**";
            var bus = new index_1.EventBus();
            bus.subscribe([greetEvent, myTargetedEventType], handleSubscription);
            bus.publish(greetEvent({ message: "Hello!" })); // Should be subscribed
            bus.publish(testFooEvent("Foo")); // Should be subscribed
            bus.publish(otherEvent("Nope")); // Should not be subscribed
            expect(handleSubscription.mock.calls).toMatchObject([
                [{ type: "greet" }],
                [{ type: "test.foo" }]
            ]);
        });
    });
    describe("metadata", function () {
        it("should be able to send metadata", function () {
            // mock subscription
            var handleSubscription = jest.fn();
            var myEventCreator = index_1.defineEvent("myevent");
            // create a bus
            var bus = new index_1.EventBus();
            bus.subscribe(myEventCreator, handleSubscription);
            // create n event
            var event = myEventCreator({ foo: "Hello" });
            // Call it once
            bus.publish(event, { remote: true });
            expect(handleSubscription.mock.calls).toEqual([
                [
                    {
                        type: "myevent",
                        payload: { foo: "Hello" },
                        meta: { remote: true }
                    }
                ]
            ]);
        });
    });
    it("should be able to append metadata", function () {
        // mock subscription
        var handleSubscription = jest.fn();
        var myEventCreator = index_1.defineEvent("myevent");
        // create a bus
        var bus = new index_1.EventBus();
        bus.subscribe(myEventCreator, handleSubscription);
        // create n event
        var event = myEventCreator({ foo: "Hello" });
        // Call it once
        bus.publish(__assign({}, event, { meta: { remote: false, thing: "foo" } }), { remote: true });
        expect(handleSubscription.mock.calls).toEqual([
            [
                {
                    type: "myevent",
                    payload: { foo: "Hello" },
                    meta: { remote: true, thing: "foo" }
                }
            ]
        ]);
    });
});
describe("namespaced events", function () {
    it("should handle namespaced events", function () {
        // mock subscription
        var handleAllSubscriptions = jest.fn();
        var handleThingsSubscriptions = jest.fn();
        var createSaveEvent = index_1.defineEvent("things.save");
        var createEditEvent = index_1.defineEvent("things.edit");
        var createFrogs = index_1.defineEvent("frogs");
        var bus = new index_1.EventBus();
        bus.subscribe("**", handleAllSubscriptions);
        bus.subscribe("things.*", handleThingsSubscriptions);
        bus.publish(createEditEvent("Foo"));
        bus.publish(createSaveEvent("Bar"));
        bus.publish(createFrogs("Gribbit"));
        expect(handleAllSubscriptions.mock.calls).toEqual([
            [{ payload: "Foo", type: "things.edit" }],
            [{ payload: "Bar", type: "things.save" }],
            [{ payload: "Gribbit", type: "frogs" }]
        ]);
        expect(handleThingsSubscriptions.mock.calls).toEqual([
            [{ payload: "Foo", type: "things.edit" }],
            [{ payload: "Bar", type: "things.save" }]
        ]);
    });
});
describe("filtering by predicate", function () {
    it("should filter event subscription using a predicate function", function () {
        // mock subscription
        var handleAllSubscriptions = jest.fn();
        var handleThingsSubscriptions = jest.fn();
        var createSaveEvent = index_1.defineEvent("things.save");
        var createEditEvent = index_1.defineEvent("things.edit");
        var createFrogs = index_1.defineEvent("frogs");
        var bus = new index_1.EventBus();
        bus.subscribe(function () { return true; }, handleAllSubscriptions);
        bus.subscribe(function (_a) {
            var type = _a.type;
            return /^things\./.test(type);
        }, handleThingsSubscriptions);
        bus.publish(createEditEvent("Foo"));
        bus.publish(createSaveEvent("Bar"));
        bus.publish(createFrogs("Gribbit"));
        expect(handleAllSubscriptions.mock.calls).toEqual([
            [{ payload: "Foo", type: "things.edit" }],
            [{ payload: "Bar", type: "things.save" }],
            [{ payload: "Gribbit", type: "frogs" }]
        ]);
        expect(handleThingsSubscriptions.mock.calls).toEqual([
            [{ payload: "Foo", type: "things.edit" }],
            [{ payload: "Bar", type: "things.save" }]
        ]);
    });
});
describe("unsubsubscribe from events", function () {
    it("should handle unsubscribing", function () {
        // mock subscription
        var handleSubscription = jest.fn();
        var myEventCreator = index_1.defineEvent("myevent");
        // create a bus
        var bus = new index_1.EventBus();
        var unsubscribe = bus.subscribe(myEventCreator, handleSubscription);
        // create n event
        var event = myEventCreator({ foo: "Hello" });
        // publish event
        bus.publish(event);
        unsubscribe();
        // subsequent calls should not fire
        bus.publish(event);
        bus.publish(event);
        expect(handleSubscription.mock.calls.length).toBe(1);
    });
});
//# sourceMappingURL=index.test.js.map